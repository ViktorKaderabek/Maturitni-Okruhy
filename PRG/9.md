<p align="right" style="font-size: 80px;">#9</p>

# Práce s polem a maticí (v C++ a C#), řadící a vyhledávací algoritmy

## Co je pole (Array) 
- Pole je kolekce podobných datových prvků uložených na sousedních místech paměti.
- Smyslem je ukládat více položek stejného typu společně.
- Jedná se o nejjednodušší datovou strukturu, kde lze ke každému datovému prvku přistupovat přímo pouze pomocí jeho indexového čísla.
- To usnadňuje výpočet pozice každého prvku jednoduchým přičtením offsetu k základní hodnotě, tj. paměťovému umístění prvního prvku pole (obvykle označenému názvem pole). 
- Array máme :
  - Klasické pole - používáme pokud již známe délku pole předem
  - List - používáme pokud neznáme délku pole předem
  - HashSet - používáme potřebujeme-li uložit 2 proměnné v jednom poli a taktéž, aby první prvek byl vždy originální (key | value)

## Základní operace s plem, práce s polem

### Metody na třídě Array
.NET nám poskytuje třídu Array, která obsahuje pomocné metody pro práci s poli. Pojďme se na ně podívat:

#### Sort()
Jak již název napovídá, metoda nám pole seřadí. Její jediný parametr je pole, které chceme seřadit. Je dokonce tak chytrá, že pracuje podle toho, co máme v poli uložené. Stringy třídí podle abecedy, čísla podle velikosti. Zkusme si setřídit a vypsat naši rodinku Simpsnů:

```csharp
string[] simpsonovi = {"Homer", "Marge", "Bart", "Lisa", "Maggie"};
Array.Sort(simpsonovi);
foreach (string s in simpsonovi)
    Console.Write("{0} ", s);
Console.ReadKey();
```

#### Reverse()
Reverse() nám pole otočí (první prvek bude jako poslední atd.), toho můžeme využít např. pro třídění pozpátku:

```csharp
string[] simpsonovi = {"Homer", "Marge", "Bart", "Lisa", "Maggie"};
Array.Sort(simpsonovi);
Array.Reverse(simpsonovi);
foreach (string s in simpsonovi)
    Console.Write("{0} ", s);
Console.ReadKey();
```

#### IndexOf() a LastIndexOf()
Tyto metody vrátí index prvního nebo posledního nalezeného prvku. V případě nenalezení prvku vrátí -1. Každá z metod bere dva parametry, prvním je pole, druhým hledaný prvek. Umožníme uživateli zadat jméno Simpsna a řekneme mu, na jaké pozici je uložený. Teď to pro nás nemá hlubší význam, protože prvek pole je jen string. Bude se nám to však velmi hodit ve chvíli, kdy v poli budeme mít uloženy plnohodnotné objekty. Berme to tedy jako takovou přípravu.

```csharp
string[] simpsonovi = {"Homer", "Marge", "Bart", "Lisa", "Maggie"};
Console.WriteLine("Ahoj, zadej svého oblíbeného Simpsna (z rodiny Simpsnů): ");
string simpson = Console.ReadLine();
int pozice = Array.IndexOf(simpsonovi, simpson);
if (pozice >= 0)
    Console.WriteLine("Jo, to je můj {0}. nejoblíbenější Simpson!", pozice + 1);
else
    Console.WriteLine("Hele, tohle není Simpson!");
Console.ReadKey();
```
#### Copy()
Copy() již podle názvu zkopíruje část pole do jiného pole. Prvním parametrem je zdrojové pole, druhým cílové a třetím počet prvků, který se má zkopírovat.

#### Metody na poli
Třída Array není jedinou možností, jak s polem manipulovat. Přímo na samotné instanci pole (konkrétní proměnné) můžeme volat také spoustu metod. I když si zmíníme jen některé, je jich opravdu hodně. Nebudeme tedy dělat příklady, jen si je popíšeme:

#### Length
Length jsme si již zmínili, vrátí délku pole. Není metodou, ale vlastností, nepíší se za ni tedy závorky ().

Následující metody jsou takzvané "extension metody". Podrobněji je probereme později. V tuto chvíli musíte jen vědět, že pro jejich zavolání potřebujeme balíček: using System.Linq; (tento kód si dopište pod: using System;)

#### Min(), Max(), Average(), Sum()
Matematické metody, vracející nejmenší prvek (Min()), největší prvek (Max()), průměr ze všech prvků (Average()) a součet všech prvků (Sum()). Metody nemají žádné parametry.

#### Concat(), Intersect(), Union()
Všechny tyto metody vrátí na výstupu nové pole a jako parametr mají druhé pole. Concat() vykoná nám již známou konkatenaci, tedy k našemu poli připojí druhé pole a takto vzniklé nové pole vrátí. Intersect() vykoná průnik obou polí, tedy sestaví pole s prvky, které jsou oběma polím společné. Union() naopak vykoná sjednocení, funguje tedy podobně jako Concat(), jen prvky, které byly v obou polích, jsou v novém poli jen jednou.

#### First() a Last()
Již podle názvu metody vrátí první a poslední prvek, neberou žádné parametry.

#### Take() a Skip()
Obě tyto metody berou jako parametr počet prvků. Take() vrátí pole s daným počtem prvků zkopírovaných od začátku původního pole. Skip() naopak vrátí pole bez těchto prvních prvků.

#### Contains()
Metoda vrací true/false podle toho, zda se prvek, uvedený v parametru metody, v daném poli nachází.

#### Reverse()
Metodu Reverse() známe již z třídy Array, pokud ji ale voláme na konkrétním poli, tak se prvky v něm neotočí, nýbrž je vytvořeno nové otočené pole a to je vráceno. Metoda nemá žádné parametry.

#### Distinct()
Distinct() je metoda bez parametrů a zajistí, aby byl v poli každý prvek jen jednou, tedy vymaže duplicitní prvky a unikátní pole vrátí jako návratovou hodnotu metody, opět tedy nemodifikuje dané pole.

Mnoho metod nemění přímo naše pole, ale vrátí pouze pole nové (jsou to metody Concat(), Intersect(), Union(), Reverse() a Distinct()), ve kterém jsou provedeny požadované změny. Pokud chceme modifikovat původní pole, musíme do něj dosadit. Tyto metody bohužel z důvodů, které pochopíme až později, nevrací přímo pole, ale typ IEnumerable. Aby bylo dosazení výsledku zpět do pole možné, musíme ho ještě převést na pole metodou ToArray().
```csharp
int[] cisla = { 1, 2, 3, 3, 3, 5 };
cisla = cisla.Distinct().ToArray();
```

## Co je matice 
- Jsou to čtvercová či obdélníková schémata složená z prvků.
- Prvky matice jsou značeny jako a_ij, kde i označuje řádek a j sloupec v matici.
- používá se nejvíce k 2D mapám, jako je u hrách, atd..
- Matice máme:
  - diagonální,
  - trojúhelníkové,
  - řádkové
  - sloupcové.

- ### Diagonální
Matice, která obsahuje nenulové prvky pouze na diagonále, se nazývá diagonální. Musí tedy platit:

a_ij = 0 pro i ≠ j
a a_ij ≠ 0 pro i = j.
Speciálním případem diagonální matice je tzv. jednotková matice. Ta musí mít na diagonále samé jedničky, tedy a_ij = 1 pro i = j:

![image](https://user-images.githubusercontent.com/66387359/152578510-eca734cb-193b-424d-964c-a1982806ae1b.png)

- ### Trojúhelníkové
Pro trojúhelníkovou matici platí, že má pod diagonálou všechny prvky rovny nule - horní trojúhelníková (vlevo), nebo nad diagonálou - dolní trojúhelníková (vpravo):

![image](https://user-images.githubusercontent.com/66387359/152578551-0951e319-96b1-41da-b62f-a1ce3524ad1a.png)

- ### Řádková matice/vektor
Tento výukový obsah pomáhají rozvíjet následující firmy, které dost možná hledají právě tebe!

Matice může mít mít samozřejmě jeden z rozměrů roven i 1. Pokud je typu 1 × n, hovoříme o tzv. řádkové matici:

![image](https://user-images.githubusercontent.com/66387359/152578580-4ea6dfc1-badf-4357-a717-06a8bbda695d.png)

- ### Sloupcový matice/vektor
V opačném případě, kdy má matice rozměry m × 1, se jedná o sloupcovou matici:

![image](https://user-images.githubusercontent.com/66387359/152578607-2b66bcb9-2cff-44cb-aa8f-d514c08daa17.png)

Priklad matice v kodu : 
```csharp
public struct Matrix
    {
        public int rows { get; private set; }
        public int columns { get; private set; }
        public double[,] data { get; private set; }

        /// <param name="m">number of rows</param>
        /// <param name="n">number of columns</param>
        public Matrix(int m, int n, Queue<double> values)
        {
            rows = m;
            columns = n;
            data = new double[m, n];

            for (int i = 0; i < m; i++)
                for (int j = 0; j < n; j++)
                    data[i, j] = values.Dequeue();
        }
    }
```

## Základní operace s maticemi, práce s maticí 
Jelikož v maticích máme zaznamenané hodnoty či data, s kterými pravděpodobně chceme nadále pracovat, potřebujeme se naučit aplikovat matematické operace.

### Negace
Někdy se nám hodí umět znegovat hodnotu, u matic to samozřejmě jde také. Stačí pro každý prvek matice otočit znaménko a výsledná matice bude negací původní:

Negace
V kódu by to vypadalo takto:
```csharp
public static Matrix operator -(Matrix A)
        {
            Queue<double> results = new Queue<double>();
            for (int i = 0; i < A.rows; i++)
                for (int j = 0; j < A.columns; j++)
                    results.Enqueue(-A.data[i, j]);

            return new Matrix(A.rows, A.columns, results);
        }
```
### Sčítání/odčítání

Sčítání a odčítání jsou velmi jednoduché operace. Obě fungují na stejném principu, a to sečtení/odečtení prvku na stejných pozicích v maticích. Vezmeme si tedy matici A typu 2 × 2 a matici B typu 2 × 2, jednoduše pak pro každé i a j uděláme operaci a_ij + b_ij. Jelikož a_ij i b_ij jsou již normální číselné hodnoty, můžeme je spolu sečíst/odečíst. Vznikne nám tedy nová matice C, kde každý prvek je výsledkem zmíněné operace. Někteří již možná postřehli, že abychom mohli operaci sčítání/odčítání provést, musí byt matice stejného typu. Nejde tedy sečíst například matici typu 2 × 3 s maticí 2 × 2.

Pro maticové sčítání navíc platí, že je komutativní a asociativní.

Příklad sčítání a odčítání matic A a B:

Sčítání a odčítání
Sčítání v kódu:
```csharp
public static Matrix operator + (Matrix A, Matrix B)
        {
            if (A.rows != B.rows || A.columns != B.columns)
                throw new InvalidOperationException("Matrices are not of the same type");

            Queue<double> results = new Queue<double>();
            for (int i = 0; i < A.rows; i++)
                for (int j = 0; j < A.columns; j++)
                    results.Enqueue(A.data[i,j] + B.data[i,j]);

            return new Matrix(A.rows, A.columns, results);
        }
```
Odčítání by bylo naprosto totožné, s pouhou změnou operátoru + na -. Abychom zbytečně neopakovali kód, můžeme využít implementace negace matice a přepsat odčítání jako přičtení negace, tedy A + (-B):
```csharp
public static Matrix operator -(Matrix A, Matrix B)
        {
            return A + (-B);
        }
```
### Násobení skalárem
Další velmi jednoduchá operace je násobení skalárem. V případě, že chceme celou matici vynásobit nějakou hodnotou n, je to to stejné, jako kdybychom n těchto matic k sobě přičetli. Platí tedy, že ve výsledné matici B je každý prvek b_ij výsledkem operace n × a_ij:

Násobení skalárem
V kódu by to mohlo vypadat takto:

```csharp
public static Matrix operator *(double multiplier, Matrix A)
        {
            Queue<double> results = new Queue<double>();
            for (int i = 0; i < A.rows; i++)
                for (int j = 0; j < A.columns; j++)
                    results.Enqueue(A.data[i, j] * multiplier);

            return new Matrix(A.rows, A.columns, results);
        }
 ```
### Násobení matice maticí
Nejtěžší ze zmíněných základních operací je určitě násobení matice maticí. Mějme matice A typu m × n a B typu k × l, které spolu chceme vynásobit. Abychom tuto operaci mohli provést, musí platit, že počet sloupců matice A je roven počtu řádků matice B - tedy n = k. Výsledná matice C má pak rozměry m x l. Jak tedy vypočteme prvky výsledné matice? Ukážeme si to na jednoduchém příkladu:

Násobení
Jak vidíme na obrázku, ve výsledné matici C je například prvek c_11 roven výsledku a_11*b_11 + a_12*b_21 + ... + a_1n*b_n1. Platí tedy, že prvek c_ij je výsledkem skalárního součinu i-tého řádku matice A a j-tého sloupce matice B.

Doplníme zbytek řádku a stejně spočítáme zbytek hodnot v dalším řádku:

Násobení
Násobení matic je asociativní, ale není komutativní. Neplatí tedy, že A × B = B × A. Pokud matici A k-krát vynásobíme sama sebou, získáme matici Ak.

Násobení matic by v kódu mohlo vypadat následovně:

public static Matrix operator *(Matrix A, Matrix B)
        {
            if (A.columns != B.rows)
                throw new InvalidOperationException("Matrices cannot be multiplied");

            Queue<double> results = new Queue<double>();
            for (int i = 0; i < A.rows; i++)
                for (int j = 0; j < B.columns; j++)
                {
                    double value = 0; ;
                    for (int k = 0; k < A.columns; k++)
                        value += A.data[i, k] * B.data[k, j];

                    results.Enqueue(value);
                }

            return new Matrix(A.rows, B.columns, results);
        }
### Transpozice matice
Tato unární operace spočívá v prohození řádků a sloupců matice. Vezmeme-li matici A typu m × n a transponujeme ji na matici, platí, že a_ij = b_ji. Jednodušeji řečeno, řádky původní matice přepíšeme jako sloupce do výsledné matice. Ta se nazývá transponovaná a má rozměry n × m:

Transpozice
Transpozice matice by vypadalo v C# takto:
```csharp
public Matrix Transpose()
        {
            Queue<double> results = new Queue<double>();
            for (int i = 0; i < rows; i++)
                for (int j = 0; j < columns; j++)
                    results.Enqueue(data[j, i]);

            return new Matrix(columns, rows, results);
        }
```

